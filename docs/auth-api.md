
# Руководство по интеграции с API аутентификации

## Общая информация

В данном документе описывается процесс интеграции фронтенда с API аутентификации системы MES. Документ содержит информацию о процессе авторизации, структуре ответов и необходимых действиях со стороны клиентского приложения.

## Авторизация пользователей

### Эндпоинт для входа в систему

**URL**: `/auth/login`  
**Метод**: `POST`  
**Содержание запроса** (JSON):

```json
{
  "username": "имя_пользователя",
  "password": "пароль"
}
```

### Ответ сервера

При успешной авторизации вы получите ответ со статусом **200 OK** и следующую структуру данных:

```typescript
{
  // JWT токен для авторизации запросов
  "token": "string", // JWT токен, который нужно сохранить и использовать для авторизации
  
  // Информация о пользователе
  "user": {
    "id": number,      // ID пользователя
    "username": string, // Имя пользователя (логин)
    "role": string,     // Роль пользователя (operator, master, admin и т.д.)
    "fullName": string  // Полное имя пользователя (может отсутствовать)
  },
  
  // Привязки пользователя (содержимое зависит от роли)
  "assignments": {
    // Для операторов - привязанные станки
    "machines": [
      {
        "id": number,         // ID станка
        "name": string,       // Название станка
        "status": string,     // Текущий статус станка
        "segmentId": number,  // ID участка, к которому привязан станок
        "segmentName": string // Название участка
      }
      // ... другие станки
    ],
    
    // Для мастеров - контролируемые участки
    "segments": [
      {
        "id": number,      // ID участка
        "name": string,    // Название участка
        "lineId": number,  // ID производственной линии
        "lineName": string // Название производственной линии
      }
      // ... другие участки
    ]
  }
}
```

### Особенности ответа в зависимости от роли пользователя

1. **Для роли "operator"**:
   - В объекте `assignments` будет присутствовать массив `machines` с информацией о станках, доступных оператору
   - Массив `segments` отсутствует

2. **Для роли "master"**:
   - В объекте `assignments` будет присутствовать массив `segments` с информацией об участках, контролируемых мастером
   - Массив `machines` отсутствует

3. **Для роли "admin"**:
   - Объект `assignments` может быть пустым, так как администраторы имеют полный доступ ко всем ресурсам системы

### Ошибки авторизации

В случае ошибки авторизации сервер вернет ответ со статусом **401 Unauthorized** и сообщением:

```json
{
  "statusCode": 401,
  "message": "Неверные учетные данные.",
  "error": "Unauthorized"
}
```

## Использование токена для авторизации запросов

После успешной авторизации все последующие запросы к API должны содержать полученный JWT токен в заголовке `Authorization`:

```
Authorization: Bearer {полученный_токен}
```

### Пример интеграции на JavaScript/TypeScript

```typescript
// Авторизация пользователя
async function login(username, password) {
  try {
    const response = await fetch('/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ username, password }),
    });
    
    if (!response.ok) {
      throw new Error('Ошибка авторизации');
    }
    
    const authData = await response.json();
    
    // Сохраняем токен (например, в localStorage)
    localStorage.setItem('auth_token', authData.token);
    
    // Сохраняем информацию о пользователе
    localStorage.setItem('user_info', JSON.stringify(authData.user));
    
    // Сохраняем привязки пользователя
    localStorage.setItem('user_assignments', JSON.stringify(authData.assignments));
    
    return authData;
  } catch (error) {
    console.error('Ошибка при входе:', error);
    throw error;
  }
}

// Функция для выполнения авторизованных запросов
async function authenticatedFetch(url, options = {}) {
  const token = localStorage.getItem('auth_token');
  
  if (!token) {
    throw new Error('Пользователь не авторизован');
  }
  
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`,
  };
  
  return fetch(url, {
    ...options,
    headers,
  });
}
```

## Время жизни токена

JWT токен имеет ограниченный срок действия - **1 час** с момента выдачи. По истечении этого времени клиентское приложение должно повторно аутентифицировать пользователя.

## Рекомендации для фронтенд-разработчиков

1. **Хранение токена**:
   - Храните токен в `localStorage` или `sessionStorage` для сохранения между сессиями
   - Для дополнительной безопасности можно использовать HTTP-only куки

2. **Обработка истечения срока действия токена**:
   - Реализуйте механизм перехвата ошибок 401 для автоматического перенаправления на страницу логина
   - При возможности, реализуйте механизм обновления токена до его истечения

3. **Привязки пользователя**:
   - Используйте полученные привязки из `assignments` для настройки интерфейса в зависимости от роли пользователя
   - Отображайте только те элементы управления и данные, которые соответствуют привязкам пользователя

4. **Проверка роли**:
   - Используйте информацию о роли пользователя (`user.role`) для управления доступом к различным разделам приложения

5. **Безопасность на клиенте**:
   - Не храните чувствительные данные пользователя (например, пароль) на клиенте
   - При выходе из системы удаляйте токен и всю информацию о сессии

## Логирование действий

Обратите внимание, что система записывает все попытки входа, включая IP-адрес и информацию о браузере пользователя. Учитывайте это при разработке интерфейса и сообщайте пользователям о такой практике в рамках политики конфиденциальности.
